A1[c(13,15,17),2,13] <- -1
A1[c(13,15,17)+1,2,13] <- 1
# item group C (define effect(A)+effect(B)+effect(C)=0)
A1[c(19,3),2,c(12,13)] <- 1
A1[c(19,3)+1,2,c(12,13)] <- -1
# A1[,2,] # look at modified design matrix
# estimate model
mod8b <- tam.mml( resp= des$gresp$gresp.noStep , A=A1 )
summary(mod8b)
data(sim.mfr) ; data(sim.facets)
# two way interaction item and rater
formulaA <- ~item+item:step + item*rater
mod9a <- tam.mml.mfr( resp=sim.mfr , facets=sim.facets , formulaA = formulaA )
mod9a$xsi.facets
summary(mod9a)
# three way interaction item, female and rater
formulaA <- ~item+item:step + female*rater + female*item*step
mod9b <- tam.mml.mfr( resp=sim.mfr , facets=sim.facets , formulaA = formulaA )
summary(mod9b)
#############################################################################
data(data.ex10)
dat <- data.ex10
head(dat)
## pid rater I0001 I0002 I0003 I0004 I0005
## 1 1 1 0 1 1 0 0
## 451 1 2 1 1 1 1 0
## 901 1 3 1 1 1 0 1
## 452 2 2 1 1 1 0 1
## 902 2 3 1 1 0 1 1
facets <- dat[ , "rater" , drop=FALSE ] # define facet (rater)
pid <- dat$pid # define person identifier (a person occurs multiple times)
resp <- dat[ , -c(1:2) ] # item response data
formulaA <- ~ item * rater # formula
mod10 <- tam.mml.mfr( resp=resp , facets=facets , formulaA = formulaA , pid=dat$pid )
summary(mod10)
# estimate person parameter with WLE
wmod10 <- tam.wle( mod10 )
#***
# Model 10 2: specification with long format response data
resp.long=c(unlist( dat[ , -c(1:2) ] ))
pid <- rep( dat$pid, ncol(dat[ , -c(1:2) ]) )
itemnames <- rep(colnames(dat[ , -c(1:2) ]), each=nrow(dat[ , -c(1:2) ]))
# quick note: the 'trick' to use pid as the row index of the facet (cf., used in Ex 8a_2)
# is not working here, since pid already occures multiple times in the original response data
facets <- cbind( data.frame("item"=itemnames),
dat[ rep(1:nrow(dat), ncol(dat[,-c(1:2)])), "rater" ,drop=F]
)
mod10_2 <- tam.mml.mfr( resp=resp.long , facets= facets , formulaA = formulaA, pid= pid )
stopifnot( all(mod10$xsi.facets$xsi==mod10_2$xsi.facets$xsi) )
#############################################################################
# EXAMPLE 11: Dichotomous data with missing and omitted responses
#############################################################################
data(data.ex11) ; dat <- data.ex11
#***
# Model 11a: Calibration (item parameter estimating) in which omitted
# responses (code 9) are set to missing
dat1 <- dat[,-1]
dat1[ dat1 == 9 ] <- NA
# estimate Rasch model
mod11a <- tam.mml( resp= dat1 )
summary(mod11a)
# compute person parameters
wmod11a <- tam.wle( mod11a )
#***
# Model 11b: Scaling persons (WLE estimation) setting omitted
# responses as incorrect and using fixed
# item parameters form Model 11a
# set matrix with fixed item difficulties as the input
xsi1 <- mod11a$xsi # xsi output from Model 11a
xsi.fixed <- cbind( seq(1,nrow(xsi1) ) , xsi1$xsi )
# recode 9 to 0
dat2 <- dat[,-1]
dat2[ dat2 == 9 ] <- 0
# run Rasch model with fixed item difficulties
mod11b <- tam.mml( resp= dat2 , xsi.fixed=xsi.fixed )
summary(mod11b)
# WLE estimation
wmod11b <- tam.wle( mod11b )
#############################################################################
# EXAMPLE 12: Avoiding nonconvergence using the argument increment.factor
#############################################################################
data(data.ex12)
dat <- data.ex12
# non-convergence without increment.factor
mod1 <- tam.mml.2pl( resp=data.ex12 , control=list( maxiter=1000) )
# avoiding non-convergence with increment.factor=1.02
mod2 <- tam.mml.2pl( resp=data.ex12 ,
control=list( maxiter=1000 , increment.factor=1.02) )
summary(mod1)
summary(mod2)
#############################################################################
# EXAMPLE 13: Longitudinal data 'data.long' from sirt package
#############################################################################
library(sirt)
data(data.long, package="sirt")
dat <- data.long
## > colnames(dat)
## [1] "idstud" "I1T1" "I2T1" "I3T1" "I4T1" "I5T1" "I6T1"
## [8] "I3T2" "I4T2" "I5T2" "I6T2" "I7T2" "I8T2"
## item 1 to 6 administered at T1 and items 3 to 8 at T2
## items 3 to 6 are anchor items
#***
# Model 13a: 2-dimensional Rasch model assuming invariant item difficulties
# define matrix loadings
Q <- matrix(0,12,2)
colnames(Q) <- c("T1","T2")
Q[1:6,1] <- 1 # items at T1
Q[7:12,2] <- 1 # items at T2
# assume equal item difficulty of I3T1 and I3T2, I4T1 and I4T2, ...
# create draft design matrix and modify it
A <- designMatrices(resp=data.long[,-1])$A
dimnames(A)[[1]] <- colnames(data.long)[-1]
## > str(A)
## num [1:12, 1:2, 1:12] 0 0 0 0 0 0 0 0 0 0 ...
## - attr(*, "dimnames")=List of 3
## ..$ : chr [1:12] "Item01" "Item02" "Item03" "Item04" ...
## ..$ : chr [1:2] "Category0" "Category1"
## ..$ : chr [1:12] "I1T1" "I2T1" "I3T1" "I4T1" ...
A1 <- A[ , , c(1:6 , 11:12 ) ]
dimnames(A1)[[3]] <- substring( dimnames(A1)[[3]],1,2)
A1[7,2,3] <- -1 # difficulty(I3T1) = difficulty(I3T2)
A <- designMatrices(resp=data.long[,-1])$A)
designMatrices(resp=data.long[,-1])
data(data.long, package="sirt")
install.packages("sirt")
data(data.long, package="sirt")
dat <- data.long
Q <- matrix(0,12,2)
colnames(Q) <- c("T1","T2")
Q[1:6,1] <- 1 # items at T1
Q[7:12,2] <- 1 # items at T2
A <- designMatrices(resp=data.long[,-1])$A
dimnames(A)[[1]] <- colnames(data.long)[-1]
## > str(A)
## num [1:12, 1:2, 1:12] 0 0 0 0 0 0 0 0 0 0 ...
## - attr(*, "dimnames")=List of 3
## ..$ : chr [1:12] "Item01" "Item02" "Item03" "Item04" ...
## ..$ : chr [1:2] "Category0" "Category1"
## ..$ : chr [1:12] "I1T1" "I2T1" "I3T1" "I4T1" ...
A1 <- A[ , , c(1:6 , 11:12 ) ]
dimnames(A1)[[3]] <- substring( dimnames(A1)[[3]],1,2)
A1[7,2,3] <- -1 # difficulty(I3T1) = difficulty(I3T2)
A1[8,2,4] <- -1 # I4T1 = I4T2
A1[9,2,5] <- A1[10,2,6] <- -1
beta.fixed <- cbind( 1 , 2 , 0 )
mod13a <- tam.mml( resp=data.long[,-1] , Q=Q , A=A1 , beta.fixed=beta.fixed)
summary(mod13a)
tammodel <- "
LAVAAN MODEL:
T1 =~ 1*I1T1__I6T1
T2 =~ 1*I3T2__I8T2
T1 ~~ T1
T2 ~~ T2
T1 ~~ T2
# constraint on item difficulties
I3T1 + I3T2 | b3*t1
I4T1 + I4T2 | b4*t1
I5T1 + I5T2 | b5*t1
I6T1 + I6T2 | b6*t1
"
# The constraint on item difficulties can be more efficiently written as
## DO(3,6,1)
## I%T1 + I%T2 | b%*t1
## DOEND
# estimate model
mod13at <- tamaan( tammodel , resp = data.long , beta.fixed=beta.fixed ,
control=list(maxiter=10))
summary(mod13at)
A <- designMatrices(resp=data.long[,-1])$A
dimnames(A)[[1]] <- colnames(data.long)[-1]
A1 <- A[ , , c(1:5 , 11:12 ) ]
dimnames(A1)[[3]] <- substring( dimnames(A1)[[3]],1,2)
A1[7,2,3] <- -1 # difficulty(I3T1) = difficulty(I3T2)
A1[8,2,4] <- -1 # I4T1 = I4T2
A1[9,2,5] <- -1
A1[6,2,3] <- A1[6,2,4] <- A1[6,2,5] <- 1 # I6T1=-(I3T1+I4T1+I5T1)
A1[10,2,3] <- A1[10,2,4] <- A1[10,2,5] <- 1 # I6T2=-(I3T2+I4T2+I5T2)
A1[,2,]
mod13b <- tam.mml( resp=data.long[,-1] , Q=Q , A=A1 , beta.fixed=FALSE)
summary(mod13b)
set.seed(42)
dat <- data.long
dat[(1:50),2] <- sample(c(0,1,2), 50, replace = TRUE)
dat[(1:50),5] <- sample(c(0,1,2), 50, replace = TRUE)
dat[(1:50),9] <- sample(c(0,1,2), 50, replace = TRUE)
## > colnames(dat)
Q <- matrix(0,12,2)
colnames(Q) <- c("T1","T2")
Q[1:6,1] <- 1 # items at T1
Q[7:12,2] <- 1 # items at T2
# (2) assume equal item difficulty of anchor items
# create draft design matrix and modify it
A <- designMatrices(resp=dat[,-1])$A
dimnames(A)[[1]] <- colnames(dat)[-1]
A1 <- A[ , , c(1:8, 14:15) ]
dimnames(A1)[[3]] <- gsub("T1|T2", "", dimnames(A1)[[3]])
# Modifications are shortened compared to Model 13 a, but are still valid
A1[7,,] <- A1[3,,] # item 7, i.e. I3T2, loads on same parameters as
# item 3, I3T1
A1[8,,] <- A1[4,,] # same for item 8 and item 4
A1[9,,] <- A1[5,,] # same for item 9 and item 5
A1[10,,] <- A1[6,,] # same for item 10 and item 6
beta.fixed <- cbind( 1 , 2 , 0 )
mod13c <- tam.mml( resp=dat[,-1] , Q=Q , A=A1 , beta.fixed=beta.fixed,
irtmodel = "PCM")
summary(mod13c)
wle.mod13c <- tam.wle(mod13c) # WLEs of dimension T1 and T2
data( data.ex14 )
dat <- data.ex14
#***
# Model 14a: facet model
resp <- dat[ , paste0("crit",1:7,sep="") ] # item data
facets <- data.frame( "rater" = dat$rater ) # define facets
formulaA <- ~item+item*step + rater
mod14a <- tam.mml.mfr( resp , facets=facets , formulaA=formulaA , pid=dat$pid )
summary(mod14a)
dataY <- dat[ , c("X1","X2") ] # latent regressors
formulaY <- ~ X1+X2 # latent regression formula
mod14b <- tam.mml.mfr( resp , facets=facets , formulaA= formulaA ,
dataY=dataY , formulaY=formulaY , pid=dat$pid)
summary(mod14b)
resp1 <- mod14a$resp # extract response data with generalized items
A <- mod14a$A # extract design matrix for item intercepts
colnames(resp1)
# define design matrix for slopes
E <- matrix( 0 , nrow= ncol(resp1) , ncol=7 )
colnames(E) <- paste0("crit",1:7)
rownames(E) <- colnames(resp1)
E[ cbind( 1:(7*7) , rep(1:7,each=7) ) ] <- 1
mod14c <- tam.mml.2pl( resp=resp1 , A=A , irtmodel="GPCM.design" , E=E ,
control=list(maxiter=100) )
summary(mod14c)
data(data.ex15)
data <- data.ex15
# facet model 'group*item' is of interest
#***
# Model 15a:
mod15a <- tam.mml.mfr(resp = data[,-c(1:2)],facets=data[,"group",drop=FALSE],
formulaA = ~ item + group*item , pid = data$pid , control=list(maxiter=50))
mod15b <- tam.mml.mfr(resp = data[,-c(1:2)],facets=data[,"group",drop=FALSE],
formulaA = ~ group*item , pid = data$pid ,
control=list(maxiter= 50 , increment.factor=1.03 , fac.oldxsi=.4 ) )
data(data.timssAusTwn.scored)
dat <- data.timssAusTwn.scored
# extract item response data
resp <- dat[ , sort(grep("M" , colnames(data.timssAusTwn.scored) , value=TRUE)) ]
# some descriptives
psych::describe(resp)
# define facets: 'cnt' is group identifier
facets <- data.frame( "cnt" = dat$IDCNTRY)
# create design matrices
des2 <- designMatrices.mfr2( resp=resp , facets=facets , formulaA = ~item*step + item*cnt)
# restructured data set: pseudoitem = item x country
resp2 <- des2$gresp$gresp.noStep
A <- des2$A$A.3d
# redundant xsi parameters must be eliminated from design matrix
xsi.elim <- des2$xsi.elim
A <- A[ , , - xsi.elim[,2] ]
# extract loading matrix B
B <- des2$B$B.3d
# estimate model
mod1 <- tam.mml( resp=resp2 , A = A , B= B , control=list(maxiter=100) )
summary(mod1)
xsi1 <- mod1$xsi
difxsi <- xsi1[ intersect( grep("cnt",rownames(xsi1)),
grep("M03" ,rownames(xsi1))) , ] - colSums(difxsi)
library(mirt)
#*** (1) simulate data in mirt package
set.seed(9897)
# simulate data according to the four-dimensional Rasch model
# variances
variances <- c( 1.45 , 1.74 , .86 , 1.48 )
corrs <- matrix( 1 , 4 , 4 )
dd1 <- 1 ; dd2 <- 2 ; corrs[dd1,dd2] <- corrs[dd2,dd1] <- .88
dd1 <- 1 ; dd2 <- 3 ; corrs[dd1,dd2] <- corrs[dd2,dd1] <- .85
dd1 <- 1 ; dd2 <- 4 ; corrs[dd1,dd2] <- corrs[dd2,dd1] <- .87
dd1 <- 2 ; dd2 <- 3 ; corrs[dd1,dd2] <- corrs[dd2,dd1] <- .84
dd1 <- 2 ; dd2 <- 4 ; corrs[dd1,dd2] <- corrs[dd2,dd1] <- .90
dd1 <- 3 ; dd2 <- 4 ; corrs[dd1,dd2] <- corrs[dd2,dd1] <- .90
covar <- outer( sqrt( variances) , sqrt(variances) )*corrs
# item thresholds and item discriminations
d <- matrix( runif(40, -2 , 2 ) , ncol=1 )
a <- matrix(NA , nrow=40,ncol=4)
a[1:10,1] <- a[11:20,2] <- a[21:30,3] <- a[31:40,4] <- 1
# simulate data
dat <- mirt::simdata(a=a, d=d, N=1000, itemtype="dich", sigma = covar )
# define Q-matrix for testlet and subdimension models estimated below
Q <- matrix( 0 , nrow=40 , ncol=5 )
colnames(Q) <- c("g" , paste0( "subd" , 1:4) )
Q[,1] <- 1
Q[1:10,2] <- Q[11:20,3] <- Q[21:30,4] <- Q[31:40,5] <- 1
# define maximum number of iterations and number of quasi monte carlo nodes
maxit <- 5 ; snodes <- 300 # this specification is only for speed reasons
variance.fct1 <- function( variance ){
ndim <- ncol(variance)
variance.new <- matrix( 0 , ndim , ndim )
diag(variance.new) <- diag(variance)
variance <- variance.new
return(variance)
}
variance.Npars <- 5 # number of estimated parameters in variance matrix
# estimation using tam.mml
mod1 <- tam.mml( dat , Q=Q , userfct.variance=variance.fct1 , variance.Npars=variance.Npars ,
control=list(maxiter=maxit , QMC=TRUE , snodes=snodes) )
summary(mod1)
variance.fct2 <- function( variance ){
ndim <- ncol(variance)
variance.new <- matrix( 0 , ndim , ndim )
diag(variance.new) <- diag(variance)
variance.new[1,2:ndim] <- variance.new[2:ndim,1] <- 0
# calculate average covariance between testlets
v1 <- variance[ -1 , -1] - variance.new[-1,-1]
M1 <- sum(v1) / ( ( ndim-1)^2 - ( ndim - 1))
v1 <- v1 - M1
variance.new[ -1 , -1 ] <- v1
diag(variance.new) <- diag(variance)
variance <- variance.new
return(variance)
}
variance.Npars <- 1 + 4 + (4*3)/2 - 1
# estimate model in TAM
mod2 <- tam.mml( dat , Q=Q , userfct.variance=variance.fct2 , variance.Npars=variance.Npars ,
control=list(maxiter=maxit , QMC=TRUE , snodes=snodes) )
summary(mod2)
variance.fct3 <- function( variance ){
ndim <- ncol(variance)
variance.new <- matrix( 0 , ndim , ndim )
diag(variance.new) <- diag(variance)
variance.new[1,2:ndim] <- variance.new[2:ndim,1] <- 0
v1 <- variance[ -1 , -1]
M1 <- mean(v1)
v1 <- v1 - M1
variance.new[ -1 , -1 ] <- v1
# ensure positive definiteness of covariance matrix
eps <- 10^(-2)
diag(variance.new) <- diag( variance.new) + eps
variance.new <- psych::cor.smooth( variance.new ) # smoothing in psych
variance <- variance.new
return(variance)
}
variance.Npars <- 1 + 4 + (4*3)/2 - 1
# estimate model in TAM
mod3 <- tam.mml( dat , Q=Q , userfct.variance=variance.fct3 , variance.Npars=variance.Npars ,
control=list(maxiter=maxit , QMC=TRUE , snodes=snodes) )
summary(mod3)
Q2 <- Q[,-5]
Q2[31:40,2:4] <- -1
# set Cov(g,u1)=Cov(g,u2)=Cov(g,u3)=0
variance.fixed <- rbind( c(1,2,0) , c(1,3,0) , c(1,4,0) )
# estimate model in TAM
mod4 <- tam.mml( dat , Q=Q2 ,variance.fixed=variance.fixed ,
control=list(maxiter=maxit , QMC=TRUE , snodes=snodes) )
summary(mod4)
Q3 <- Q[,-1]
# define fitting function using the lavaan package and ULS estimation
N0 <- nrow(dat) # sample size of dataset
library(lavaan) # requires lavaan package for fitting covariance
variance.fct5 <- function( variance ){
ndim <- ncol(variance)
rownames(variance) <- colnames(variance) <- paste0("F",1:ndim)
lavmodel <- paste0(
"FHO =~" , paste0( paste0( "F" , 1:ndim ) , collapse="+" ) )
lavres <- lavaan::cfa( model=lavmodel , sample.cov=variance , estimator = "ULS" ,
std.lv=TRUE , sample.nobs=N0)
variance.new <- fitted(lavres)$cov
variance <- variance.new
# print coefficients
cat( paste0( "\n **** Higher order loadings: " ,
paste0( paste0( round( coef(lavres)[ 1:ndim ] , 3 )) , collapse=" ")
) , "\n")
return(variance)
}
variance.Npars <- 4+4
# estimate model in TAM
mod5 <- tam.mml( dat , Q=Q3 , userfct.variance=variance.fct5 , variance.Npars=variance.Npars ,
control=list(maxiter=maxit , QMC=TRUE , snodes=snodes) )
summary(mod5)
Q2 <- Q[,-5]
Q2[31:40,2:4] <- -1
# fixed covariances
variance.fixed2 <- rbind( c(1,2,0) , c(1,3,0) , c(1,4,0) )
E <- array( 0 , dim = c( 40 , 2 , 4 , 4 ) )
E[ 1:10 , 2 , c(1,2) , 1 ] <- 1
E[ 11:20 , 2 , c(1,3) , 2 ] <- 1
E[ 21:30 , 2 , c(1,4) , 3 ] <- 1
E[ 31:40 , 2 , 1 , 4 ] <- 1
E[ 31:40 , 2 , 2:4 , 4 ] <- -1
# constraint on slope parameters, see Brandt (2012)
gammaconstr <- function( gammaslope ){
K <- length( gammaslope)
g1 <- sum( gammaslope^2 )
gammaslope.new <- sqrt(K) / sqrt(g1) * gammaslope
return(gammaslope.new)
}
mod6 <- tam.mml.3pl( dat, E=E, Q=Q2, variance.fixed=variance.fixed2, skillspace="normal",
userfct.gammaslope = gammaconstr , gammaslope.constr.Npars = 1 ,
control=list(maxiter=maxit , QMC=TRUE , snodes=snodes ) )
summary(mod6)
data(data.Students, package="CDM")
dat <- data.Students[ , c( paste0("sc",1:4) , paste0("mj",1:4) ) ]
# specify dimensions in Q-matrix
Q <- matrix( 0 , nrow=8 , ncol=2 )
Q[1:4,1] <- Q[5:8,2] <- 1
# partial credit model with some constraint on item parameters
mod1 <- tam.mml( dat , Q=Q , irtmodel="PCM2" , constraint="items")
summary(mod1)
rm(list=ls())
require(TAM)
ctl.list<-list(progress=FALSE)
data(data.gpcm)
dat<-data.gpcm
I <- ncol(dat)
est.guess <- 1:I
# starting values guessing parameter
guess <- .2*(est.guess > 0)
# estimate model
mod <- tam.mml.3pl(resp=dat , skillspace= "normal" , gammaslope.des="2PL" ,
control=ctl.list , est.guess = est.guess , guess=guess, est.variance=FALSE)
summary(mod)
mod$rprobs
apply(mod$rprobs,2,sum)
sapply(1:3,function(x){
apply(mod$rprobs[x,,],1,sum)
})
sapply(1:3,function(x){
apply(mod$rprobs[x,,],2,sum)
})
p<-rprobs[,1,]+rprobs[,2,]+rprobs[,3,]+rprobs[,4,]
rprobs<-mod$rprobs
p<-rprobs[,1,]+rprobs[,2,]+rprobs[,3,]+rprobs[,4,]
p
help(tam)
help(tam.mml.3pl)
E0<-matrix(c(0,0,0,0.3,0.4,0.5,0.7,0.8,0.7,1,1,0.9),nrow=3)
E0
E<-array(0,dim=c(I,4,1,3))
E
E0<-matrix(c(0,0,0,0.3,0.4,0.5,0.7,0.8,0.7,1,1,0.9),nrow=3)
E<-array(0,dim=c(I,4,1,3))
for (i in 1:I)
for (k in 1:4)
E[i,k,1,i]<-E0[i,k]
E
mod <- tam.mml.3pl(resp=dat , skillspace= "normal" , gammaslope.des="2PL" ,
control=ctl.list , E=E, est.variance=FALSE)
summary(mod)
c(.744,1.732)/2.48
c(.356,.7113)/.891
c(4.57,6.398)/8.226
E
c(4.57,6.398)/8.226*.9
rprobs[,1,]+rprobs[,2,]+rprobs[,3,]+rprobs[,4,]
rprobs[,1,]
b<-read.table("L:\\dvd\\irt\\ming\\EL10402T1(wu)-fix.prm2")
b<-b$V1
b
require("RGtk2")
window <- gtkWindow()
window["title"] <- "uirt"
frame <- gtkFrameNew("uirt")
window$add(frame)
manipulate ( ## e x p r e s s i o n
plot ( cars , xlim = c ( x.min , x.max ) , type = type ,
axes = axes , ann = label ) ,
## c o n t r o l s
x.min = slider ( 0 , 15 ) ,
x.max = slider ( 15 , 30 , initial = 25 ) ,
type = picker ( "p" , "l" , "b" , "c" , "o" , "h" , "s" ) ,
axes = checkbox ( TRUE , label = "Draw Axes" ) ,
label = checkbox ( FALSE , label = "Draw Labels" )
)
library(RGtk2)
manipulate ( ## e x p r e s s i o n
plot ( cars , xlim = c ( x.min , x.max ) , type = type ,
axes = axes , ann = label ) ,
## c o n t r o l s
x.min = slider ( 0 , 15 ) ,
x.max = slider ( 15 , 30 , initial = 25 ) ,
type = picker ( "p" , "l" , "b" , "c" , "o" , "h" , "s" ) ,
axes = checkbox ( TRUE , label = "Draw Axes" ) ,
label = checkbox ( FALSE , label = "Draw Labels" )
)
rm(list=ls())
setwd("L:/github/uirttool")
source("Pcx.R")
source("Gpx.R")
source("Nrm.R")
source("readTPcx.R")
source("readTGpx.R")
source("readCPcx.R")
source("likelihood.R")
source("tcc.R")
source("PcxDesign.R")
source("GpxDesign.R")
source("ck2bk.R")
source("getBks.R")
source("cqcdata2tam.R")
source("pickCqcResp.R")
source("stItems.R")
item<-eval(parse("Gpc(name=\"V1\",a=0.99,bk=c(-1.9,0.2,-0.5,1.1))"))
plot(item)
source("Gpc.R")
item<-eval(parse("Gpc(name=\"V1\",a=0.99,bk=c(-1.9,0.2,-0.5,1.1))"))
item<-eval(parse(text="Gpc(name=\"V1\",a=0.99,bk=c(-1.9,0.2,-0.5,1.1))"))
plot(item)
class(item)
plot.uirt
source("plot.uirt.R")
plot(item)
plot(item,thetas=seq(-6,6,len=100))
source("ItemString.R")
plot(item,thetas=seq(-6,6,len=100))
